---
layout: post
title: Garden, hypothethical language syntax
---

I've often asked myself as I work throughout the day, as I jump from language to language... _what would it look like for my 'ideal' syntax?_ If I were to design a programming language, what system by which would I design it? How would I go about making decisions? What would it look like? This document is the beginning of a plan for a hypothetical language syntax. It will change, grow, and update frequently as I continue to research for the project. I'm still exploring this idea. So anything in this document is likely and open to change. There is no plan to implement this syntax.

Version 0.0.0 - Planning; See [SemVer](http://semver.org/)

Principles
----------

- Be consistent, even across types.
- Omit the obvious, but be explicit.
- Separate data and procedures.
- Prefer one way to do things, and explain exceptions.
- Test readability: I should be able to read it outloud to a non-programmer as-is.
- Flat, unabstracted.
- Throw errors often.
- Namespace.

Syntax
------

**Lines and blocks.** In Garden, lines are terminated by the `\n` newline character. Parenthesis can be used for line continuation if needed. Blocks are indicated by indentation. Indentation is 4 spaces by default.

**Variables.** Variables are declared with a simple `=` equal sign. No keywords are required.

    a = 1
    b = 2

Variables are dynamic; they only refer to data. As such, variables can be overwritten with other types.

    a = 1
    a = 'string'

Variables are scoped as locally as possible. There are no global variables. Variables are either scoped to the module, to a function, or to a specific block. Garden is fully UTF-8 compatible by default.

    a = 1  ; Scoped to the module
    f = ()  ; Function declaration
        b = 2  ; `b` is scoped to the function
        if b eq a
            a = 5  ; `a` is still the module scope
            c = 3  ; `c` is scoped to `if`
            ã‚¢ = 4  ; UTF-8

Garden is garbage-collected.

**Comments.** Comments start with a `;` character. Block comments are possible by forming a block under a `;` character. Semicolons are the comment character because semicolons a) require only one key, b) are easy to reach, and c) aren't mistaken for another operation.

    ; An inline comment
    ;
        A block comment

Basic Data Types
----------------

Data types in Garden are purely data, and do not have any operations (e.g. methods, functions) of their own. In the below examples, we will use
_aliases_, as described in a later section, for syntactical convenience.

Every data type has one, and only one, "falsy" representation.

Most data types are immutable by default; they are essentially cloned when making updating operations. The mutable versions of data types are typically prefixed by `$`.

**None.** Perhaps the most basic type is `none`. `none` is always the default value. `none` is always falsy. `none` is an immutable type; the value cannot be changed. `none` is not a number or boolean and attempts to use it as such will throw an error.

    none
    a  ; defaults to simply `none`
    if none  ; converted to `false`
        b = 1

**Boolean.** Booleans are either `true` or `false`, with `false` being the falsy value. Booleans are not treated as numbers, and attempts to use aliases for numbers will throw an error. Booleans are always immutable.

    a = true
    b = false
    if a isnt b
        c = true

**Number.** There is only one type of number. Numbers have by far the largest number of aliases available, such as `+` and `*`. `0` is the falsy value. Garden will try to keep representations for as long as possible, using [lazy evaluation](http://en.wikipedia.org/wiki/Lazy_evaluation) ensuring that the final output has the best floating point representation possible. Numbers are always immutable.

    1 + 1  ; creates a new number, 2
    1 - 1
    1 / 1
    1 * 1
    1 + 1 * 1  ; with aliases, order of operations is used
    (1 + 1) * 1  ; Parenthesis can be used to overwrite order of operations.
    1 ^ 1
    1 % 1
    1++

**String.** Strings use only the single-quote `'` character. Regular expressions are just strings. `\'` is the escaped version of the single quote character. Strings can be defined in multiple lines with indentation just like comments. `''`, empty string, is the falsy value. The indentation is stripped. Numbers and strings cannot be concatenated and attempts to do so will throw an error. Strings are always immutable.

    a = 'Hello world'
    a.0  ; 'H', this is similar to an array alias
    a + '!'  ; 'Hello world!'
    '\''  ; \ escapes
    b = '  ; A multiline string
        Hello
        world

**Tuple.** Tuples are defined with `[]`. Tuples are zero-indexed. The falsy value of tuple is the empty tuple, `[]`. Tuples are immutable. Tuples can only store other immutable data types, such as boolean, number, string, tuple, and hash.

    @ tuple
    a = [1, 2, 3]  ; Inline format.
    b = [
        1
        2
        3
    ]  ; Block format.
    a.0  ; 1
    tuple.push(a, 4)  ; [1, 2, 3, 4], a new tuple.

**Array.** Arrays are defined with `$[]`. Arrays are almost completely identical to tuples. The only exception is that arrays are mutable, and array operations will change the contents of the array. Arrays are dynamically sized. Arrays can store immutable data, mutable data, and functions. When an array has a reference to mutable data or a function, it only stores the reference.

    @ array
    $a = $[1, 2, 3]
    $a.0  ; 1
    array.push($a, 4)  ; [1, 2, 3, 4], updated value of `$a`.
    $a.3 = 4  ; Updates `$a` in place. Not allowed on tuples.
    array.copy($a)  ; Creates a new version of `$a`.

**Hash.** Hases are defined with `{}`. Hashes are immutable. Hashes are unordered. Hashes support embedding. The falsy form of hash is an empty hash, `{}`. Hashes may only store immutable data types.

    @ hash
    q = {'a' = 1, 'b' = 2, 'c' = 3}  
    ; Keys are explicit string, other types allowed
    q = {
        'a' = 1
        'b' = 2
        'c' = 3
    }  ; In block format
    q.a  ; Get a value
    hash.delete(q, 'a')  ; Creates a new hash without `a` attribute.

**Object.** Objects are defined with `${}`. Objects are almost completely identical to hashes. The only exception is that objects are mutable, and object operations will change the contents of the object. Like arrays, objects can store immutable data, mutable data, and functions. When an object has a reference to mutable data or a function, it only stores the reference.

    @ object
    $q = ${'a' = 1, 'b' = 2, 'c' = 3}
    $q.a  ; Get a value
    $q.a = 1  ; Set a new value. Not allowed on hashes.
    object.delete($q, 'a')  ; Updates `$q` in place.

Classes, and by extension object-oriented programming, are not available in the standard library.

**Module.** Each file is considered a unique namespace. To import data and functions from other files, use the `import` function. If a cycle is formed with `import`, the compiler will throw an error.

    module = import('./path/to/module')

By default, everything in the module is made available. You can specify with the remaining arguments a more limited set.

    module = import('./path/to/module', 'a', 'b', 'c')

Some modules are part of the standard library, such as the `type` module.

    type = import('type')
    a = type.toString(1)  ; converts type
    b = type.getType(2)  ; returns type as a string

A alias of `import` is `@`. When using the alias, strings are assumed. It will be set to the name of the module, but prefixing with an assignment can change the name.

    @ ./path/to/module
    partial = @ ./path/to/module, a, b, c

Functions and Control Statements
--------------------------------

**Functions.** Functions are defined by a set of arguments in `()`, followed by an indented block. When arguments are defined in block form, commas are not required.

    add = (a, b)
        return a + b

    add = (
        a
        b
    )  ; In block format.
        return a + b

Functions are called by reference. Function calls use [lazy evaluation](http://en.wikipedia.org/wiki/Lazy_evaluation) to avoid excessive computation.

    add(1, 2)  ; computed as 3

Functions carry some properties of data types, in that functions can also be passed by reference to other functions.

    async(1, add)

The number of arguments do not have to match the function definition when calling.

    add(1)
    add(1, 2, 3)

Functions allow recursion.

Functions which receive mutable types as arguments should also have `$` prefixed to indicate the function mutates data.

**Conditionals.** `if` statements are a very familiar syntax.

    f = (a, b)
        if a is b
            return true
        else
            return false

Conditional blocks can also be used for assignment.

    c =
        if a is b
            true
        else
            false

Thanks to the aliases, chained comparisons are allowed.

    if a > b > c
        return true

Type must be explicitly converted for comparison. `if` statements do not convert type. If you try to compare two different types, you will get an error.

**Loops.** Both `while` and `for` loops are available. `while` loops expect a boolean and a block.

    while true
        add(1, 2)

`for` loops expect an iterative and a block. An iterative always takes the expression `for {variable(s)} in {data}`.

    for i in [0, 1, 2]
        add(a, i)

    for i in range(0, 10)
        add(a, i)

    for index, value in range(0, 10)
        a[index] = value

    for value in {'a' = 1, 'b' = 2}
        add(a, value)

    for key, value in {'a' = 1, 'b' = 2}
        a[key] = value

`break` and `continue` are available as is common in most languages.

**Error Handling.**

    try
        statements
    catch exception
        statements

    assert condition

    throw exception

Aliases
-------

While being largely a functional language (with a few mutable data types), aliases give Garden a much more familiar syntax. Aliases are not required, the language can be fully used without touching a single alias.

**Common aliases.** Unlike their functional equivalents, aliases do observe standard order of operations.

- `=` is an alias of `set()`
- `+` is an alias of `add()` or `concat()`
- `-` is an alias of `subtract()`
- `*` is an alias of `multiply()`
- `\` is an alias of `divide()`
- `^` is an alias of `power()`
- `%` is an alias of `modulus()`
- `@` is an alias of `import()`
- `and` is an alias of `and()`
- `or` is an alias of `or()`
- `not` is an alias of `not()`
- `is` is an alias of `is()`
- `eq` is an alias of `equals()`
- `isnt` is an alias of `not(equals())`
- `<` is an alias of `lessThan()`
- `>` is an alias of `greaterThan()`
- `<=` is an alias of `or(lessThan(), equals())`
- `>=` is an alias of `or(greaterThan(), equals())`
- `?` aliases `equals(getType(a), none)`
- `++` aliases `increment(n, 1)`
- `--` aliases `decrement(n, 1)`
- `+=` aliases `increment(a, b)`
- `-=` aliases `decrement(a, b)`

To get a feel for what's happening underneath, here's a few examples of things that are equivalent expressions.

    1 + 2
    add(1, 2)

    1 + 2 * 3
    add(1, multiply(2, 3))

    1 * 2 + 3
    add(multiply(1, 2), 3)

    true and true
    and(true, true)

    [1, 2, 3].0
    get([1, 2, 3], 0)

    $[1, 2, 3].0 = 2
    set($[1, 2, 3], 0, 2)

**Non-alias keywords.** Several control statements are not aliases. `if`, `else`, `for`, `while`, `break`, `continue`, `return`, `try`, `catch`, `assert`, and `throw` are not aliases. They are part of the core language.

**Accessor aliases.** Tuples, arrays, hashes, and objects provide commonplace aliases for accessing and setting values.

- `.` aliases `get()` and `set()`. This alias interpolates type as number or string.
- `[]` also aliases `get()` and `set()`. `[]` does not interpolate type.
- `contains` and `in` are aliases of `in()`.

**Comprehensions.** Comprehensions, borrowed from Python, are more complex aliases that provide convenience for crafting new tuples, arrays, hashes, and objects from existing data.

    [a for a in [0, 1, 2]]

    A = []
    for a in [0, 1, 2]
        A.append(a)

    {k = v for k, v in {'a' = 1, 'b' = 2, 'c' = 3}}

**Destructure alias.** A tuple or array of items can be assigned to individual elements.

    a, b = [0, 1]
    set(a, 0)
    set(b, 1)

**Inline-block alias.** It's often common to have one line functions which serve as an input to another function. In such cases, it may be inconvenient to require a line break. In such cases, the inline-block alias, a colon `:`, can be used.

    filter(c, (a): return a.name == 'A')
    filter(c, (a)
        return a.name == 'A')

**Ternary alias.** Many languages feature some kind of way to set a variable based on condition in a single line. It's common to have a variable set by a simple condition. The ternary alias replicates this capability.

    a = if b > 5 then 5 else b
    a = if b > 5
        5
    else
        b

**Chain alias.** Performing a set of operations on a collection of items, such as filter, map, sort, and reduce can be awkward looking.

    b = reduce(sort(map(filter(a, (c): ...), (c): ...), (c): ...), (c): ...)

Such calls can hide the step-by-step nature of these commands. Instead the chain alias takes the previous value and adds it as the first argument of the succeeding function call.

    b = a
        -> filter((c): ...)
        -> map((c): ...)
        -> sort((c): ...)
        -> reduce((c): ...)

The operator can be used on the same line or on successive lines.

**Keyword alias.** Functions are always in keyword style. This means argument names can always be added for clarity. Without argument names, functions assume the ordering matches the arguments.

    add(b = 2, a = 1)

**Splat alias.** Splats can be used to refer to an addition arguments. Splats are identified as `...`, and may use numeric indexes or strings.

    add = (...)
        return add(...0, slice(..., 1))

**Type annotation alias.** Optionally, function arguments and returns can have type specified. These simply add runtime warnings, and are not complier enforced or checked as Garden is a dynamic language.

    add = (a:number, b:number)
        return a + b
    (:number)

Custom Data Types
-----------------

When creating custom data types, other aliases can be defined. Custom data types can be defined. TODO: How do we create these?

Custom data types are not classes. Custom data types can define aliases, and therefore impact how the language itself is compiled.

**Vector.** Vectors are immutable. Vectors are defined as `vector[]` or `vector{}`, supporting implied numeral keys `[]` or other types of keys `{}`. The falsy vector is an empty vector.

**Matrix.** Matrixes are immutable. Matrixes are defined either as `matrix[]` or `matrix{}`, supporting implied numeral keys `[]` or other types of keys `{}`. The falsy matrix is an empty matrix.

**Fraction.**

**Irrational.**

**Date.**

Compiler
--------

Garden uses a 'watch'-based compiler, meaning as changes are detected, the code recompiles. A fast C-based compiler is available for desktop applications, server-side website code, and shell scripting. A JavaScript compiler is available for client-side websites and other scripting applications.

The compiler automatically lints the code for best practices. Some issues will cause the compiler to fail to build, while others will show warnings instead.

Errors: (_Must_)

- Each indent should be four spaces per indent.
- Functions must contain less than ten statements.
- Blocks must not go more than three levels deep.
- Types must match to do a comparison. (Run-time)

Warnings: (_Should_)

- One empty line should be after each block.
- Two spaces should be before starting an inline comment.
- Mutable variable name should be prefixed with `$`. (Run-time)
    - `$` prefix indicates the variable _may_ be mutable, in the case of a function argument.
- One space should be around operator aliases. `= + - / * ^ % :`
- No spaces should be inside binding aliases. `( ) [ ] { }`
- Variable names should be either camelcase or underscores, but not both.
- All imports should be used.
- All variables should be used.
- No lines should have trailing whitespace.
- Lines should be no longer than eighty characters.
- Functions should always end in an explicit return.

Compilations only include specific modules needed.

Standard Library
----------------

Standard library modules version separate of the main language.

**String.** in, find, lowercase, concat, trim, replace, template, split, reverse. `template` interpolates `{var}`.

**Tuple.** length, get, slice, before, after, set, concat, join

**Array.** Tuple methods, plus push, pop, shift, unshift, copy...

Example Case: Quicksort
-----------------------

Garden has two syntaxes, one without aliases and one with. Here's a quicksort algorithm without aliases:

    set(array, import('array'))
    set(random, import('random'))
    set(number, import('number'))
    set(quicksort, (a)
        set($less, $[])
        set($equal, $[])
        set($greater, $[])
        if number.greaterThan(array.length(a), 1)
            set(pivot, random.select(array))
            for x in a
                if number.lessThan(x, pivot)
                    array.append($less, x)
                if number.equals(x, pivot)
                    array.append($equal, x)
                if number.greaterThan(x, pivot)
                    array.append($greater, x)
            return array.concat(
                array.concat(quicksort($less), $equal),
                quicksort($greater)
            )
        else
            return a
    )

With aliases:

    @ array
    @ random
    quicksort = (a)
        $less, $equal, $greater = $[], $[], $[]
        if array.length(a) > 1
            pivot = random.select(a)
            for x in a
                if x < pivot
                    $less + x
                if x == pivot
                    $equal + x
                if x > pivot
                    $greater + x
            return quicksort($less) + $equal + quicksort($greater)
        else
            return a

Example Case: Object-Oriented Programming
-----------------------------------------

While Garden is largely a functional-ish language, it doesn't prevent some object-oriented programming style.

Consider the following **non-Garden** code, which looks like a typical class in other languages.

    ; This is not Garden code
    printer = class  ; Garden does not ship with a class type
        new = (props)
            ; Add properties to instance
        print = ()
            console.print(this.name)  ; Garden has no context of the instance
            return this.name

Garden does allow storing function references on objects. However, those functions will not have any "context" of how they are called like in the previous non-example.

    @ console

    $a = ${}
    $a.name = 'A'
    $a.print = ($a)
        console.print($a.name)
        return $a.name
    $a.print()  ; Has no context of `a`

Methods, in the OOP sense, are not possible without an instance context. Garden also does not ship with a class data type. Instead, by clever use of the chain operator, we can create modules that act as classes.

    ; First module acting as class, `printer`

    @ object
    @ console

    new = (props)
        return object.extend(${}, props)

    print = ($ins)
        console.print($ins.name)
        return $ins.name

    ; Another module

    p = @ ./printer

    $a = p.new(${})
    $b = p.new(${})
    $a -> p.print()
    $b -> p.print()

This isn't exactly object-oriented programming per say, but we gain a few advantages. As functions have no context, its very clear what the inputs are to the function. And because the functions don't belong to a specific object or class, we can reuse them directly without having to consider context as well. This process also forces us to do class-by-composition instead of class-by-inheritance.

More TODOs
----------

- TODO: standard lib module for All data types
- TODO: Reading command line arguments
- TODO: File
- TODO: Exceptions
- TODO: Events and concurrency
- TODO: Threads
- TODO: Message queue and observer pattern
- TODO: Parallel
- TODO: Serialization
- TODO: State machines
- TODO: Math
- TODO: Map Reduce
- TODO: Numeric computation, linear algebra
- TODO: Calculus
- TODO: Combinatorics
- TODO: Statistics
- TODO: REPL
- TODO: Test suites
- TODO: Source maps
- TODO: SQL library
- TODO: Web server
- TODO: Proxy server
- TODO: Web MVC
- TODO: ORM and Migration framework
- TODO: Drivers for popular tools
- TODO: Task runner (e.g. Grunt)
- TODO: Date and Time
- TODO: Heaps, Sets, Queues...
- TODO: Pretty Print
- TODO: Cryptography
- TODO: Compression
- TODO: CSV
- TODO: Logging
- TODO: SSL, HTTP
- TODO: Email
- TODO: JSON
- TODO: Mime
- TODO: HTML
- TODO: XML
- TODO: URL
- TODO: FTP
- TODO: Cookie
- TODO: Audio
- TODO: Image
- TODO: Video
- TODO: OpenGL
- TODO: Fonts
- TODO: CSS
- TODO: Color
- TODO: Internationalization
- TODO: Machine learning
- TODO: Text processing and analysis
- TODO: GUI
- TODO: Doc generator
- TODO: Test suites
- TODO: Debugging
- TODO: Compiler
- TODO: Mac, Unix, Windows Services
- TODO: Plotting
- TODO: Markdown
- TODO: Shell
- TODO: Benchmarking
- TODO: Vagrant/Docker
- TODO: Web socket
- Why? and Why Not? for each decision, pros and cons from other languages
- Review MDN JS Guide
- Review MDN JS Reference
- Review TC39 ECMA-262
- Review http://bonsaiden.github.io/JavaScript-Garden/
- Review Python docs
- Review Ruby docs
- Review Java docs
- Review Coffeescript docs
- Review Lua docs
- Review D docs
- Review Scala docs
- Review Other languages docs
- Review Bitwise operations (?)
- Promises and Async as default for libraries (ala Node.js)
- Review [YACC](http://en.wikipedia.org/wiki/Yacc)
- Write a blog in exclusive literal style to observe natural syntax
- Review [Wolfram's language](http://www.wolfram.com/language/for-experts/)
- Review Lisp docs (compiled, dynamic language)
- Review Go docs
- Review Dart docs
- Review Fortran docs
- Review [Swift docs](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_399)
- Review [wisp docs](https://github.com/Gozala/wisp)
- Review Clojure docs
- Review Matlab, Octave, R docs
- Review LaTeX docs
