---
layout: post
title: Garden, hypothethical language syntax
---

I've often asked myself as I work throughout the day, as I jump from language to language... _what would it look like for my 'ideal' syntax?_ If I were to design a programming language, what system by which would I design it? How would I go about making decisions? What would it look like? This document is the beginning of a plan for a hypothetical language syntax. It will change, grow, and update frequently as I continue to research for the project. I'm still exploring this idea. So anything in this document is likely and open to change. There is no plan to implement this syntax.

Version 0.0.0 - Planning; See [SemVer](http://semver.org/)

Principles
----------

- Be consistent, even across types.
- Omit the obvious, but be explicit.
- Separate data and procedures.
- Prefer one way to do things, and explain exceptions.
- Test readability: I should be able to read it outloud to a non-programmer as-is.
- Flat, unabstracted.
- Throw errors often.
- Namespace.

True Garden
-----------

Garden has two syntaxes. First, I will introduce the True Garden syntax. True Garden is simple but verbose.

### Data, Functions, and References

At its heart, Garden only has three types of things: data, functions, and references.

**Data**. Data is rather pure. Examples are boolean, numbers, strings, maps, and tuples. Data by default is immutable, though mutable types are available. Data does not own functions. Garden has no classes, but new data types can be created in a low-level fashion.

**Functions**. Functions in Garden can be either immutable or mutable. Functions are first-class.

**References**. References, or variables, are plain text in Garden. References to any mutable data, and functions which receive or return mutable data, must start their name with a `$`.

### Syntax Basics

**Lines and blocks.** In Garden, lines are terminated by the `\n` newline character. Parenthesis can be used for line continuation if needed. Blocks are indicated by indentation. Indentation is 4 spaces by default.

**Comments.** Comments start with a `;` character. Block comments are possible by forming a block under a `;` character. Semicolons are the comment character because semicolons a) require only one key, b) are easy to reach, and c) aren't mistaken for another operation.

    ; An inline comment
    ;
        A block comment

**Setting references.** References are declared with a simple `set()` function. No keywords are required.

    set(a, 1)

References are dynamic. References only refer to data or functions. As such, references can be overwritten with other types.

    set(a, 1)
    set(a, 'string')

References are scoped as locally as possible. Coders cannot set global references. References are either scoped to the module, to a function, or to a specific block. Garden is fully UTF-8 compatible by default.

    set(a, 1) ; Scoped to the module
    set(f, ()  ; Function declaration
        set(b, 2)  ; `b` is scoped to the function
        if eq(a, b)
            set(a, 5)  ; `a` is still the module scope
            set(c, 3)  ; `c` is scoped to `if`
            set(ã‚¢, 4)  ; UTF-8
    )

Garden is garbage-collected.

### Basic Data Types

Data types in Garden are purely data, and do not have any operations (e.g. methods, functions) of their own.

Every data type has one, and only one, "falsy" representation.

Most data types are immutable by default. Data types are cloned when making updating operations. The mutable versions of data types are typically prefixed by `$`.

**None.** The most basic type is `none`. `none` is always the default value. `none` is always falsy. `none` is an immutable type; the value cannot be changed. `none` is not a number or boolean and attempts to use it as such will throw an error.

    none
    a  ; defaults to `none`
    if none  ; means `false`
        set(b, 1)

**Boolean.** Booleans are either `true` or `false`, with `false` being the falsy value. Booleans are not treated as numbers, and attempts to use operations for numbers will throw an error. Booleans are always immutable.

    set(a, true)
    set(b, false)
    if isnt(a, b)
        set(c, true)

**Number.** There is only one type of number.`0` is the falsy value. Garden will try to keep representations for as long as possible, using [lazy evaluation](http://en.wikipedia.org/wiki/Lazy_evaluation) ensuring that the final output has the best floating point representation possible. Numbers are always immutable.

    add(1, 1)  ; creates a new number, 2
    subtract(1, 1)  ; create a new number, 0
    divide(1, 1)
    multiply(1, 1)
    multiply(add(1, 1), 1)
    power(1, 1)
    modulus(1, 1)
    increment(a, 1)

**String.** Strings use only the single-quote `'` character. Regular expressions are just strings. `\'` is the escaped version of the single quote character. Strings can be defined in multiple lines with indentation just like comments. `''`, empty string, is the falsy value. The indentation is stripped. Numbers and strings cannot be concatenated and attempts to do so will throw an error. Strings are always immutable.

    set(a, 'Hello world')
    get(a, 0)  ; 'H', this is similar to an array
    concat(a, '!')  ; 'Hello world!'
    '\''  ; \ escapes
    set(b, '  ; A multiline string
        Hello
        world
    )

**Tuple.** Tuples are defined with `[]`. Tuples are zero-indexed. The falsy value of tuple is the empty tuple, `[]`. Tuples are immutable. Tuples can only store other immutable data types, such as boolean, number, string, tuple, and hash.

    set(a, [1, 2, 3])
    get(a, 0)  ; 1
    push(a, 4)  ; [1, 2, 3, 4], a new tuple.

**List.** Lists are defined with `$[]`. Lists are almost completely identical to tuples. The only exception is that lists are mutable. List operations will change the contents of the list. Lists are dynamically sized. Lists can store immutable data, mutable data, and functions. When an list has a reference to mutable data or a function, it only stores the reference.

    set($a, $[1, 2, 3])
    get($a, 0)  ; 1
    push($a, 4)  ; [1, 2, 3, 4], updated value of `$a`.
    set($a, 3, 4)  ; Updates `$a` in place. Not allowed on tuples.
    copy($a)  ; Creates a new version of `$a`.

**Map.** Maps are defined with `{}`. Maps are immutable. Maps are unordered. Maps support embedding. The falsy form of map is an empty map, `{}`. Maps may only store immutable data types.

    set(q, {'a' = 1, 'b' = 2, 'c' = 3})
    ; Keys are explicit string, other types allowed
    get(q, 'a')  ; Get a value
    delete(q, 'a')  ; Creates a new map without `a` attribute.

**Object.** Objects are defined with `${}`. Objects are almost identical to maps. The only exception is that objects are mutable. Object operations will change the contents of the object. Like lists, objects can store immutable data, mutable data, and functions. When an object has a reference to mutable data or a function, it only stores the reference. Classes, and by extension object-oriented programming, are not available in the standard library.

    set($q, ${'a' = 1, 'b' = 2, 'c' = 3})
    get($q, 'a')  ; Get a value
    set($q, 'a', 1)  ; Set a new value. Not allowed on maps.
    delete($q, 'a')  ; Updates `$q` in place.

**Module.** Each file is considered a unique namespace. To import data and functions from other files, use the `import` function. If a cycle is formed with `import`, the compiler will throw an error. Everything in the module is made available.

    set(module, import('./path/to/module'))

Some modules are part of the standard library, such as the `type` module.

    set(type, import('type'))
    set(a, type.toString(1))  ; converts type
    set(b, type.getType(2))  ; returns type name as a string

TODO mutability of modules? encapsulation of data? name aliasing?

### Functions and Control Statements

**Functions.** Functions are defined by a set of arguments in `()`, followed by an indented block.

    set(myAdd, (a, b)
        @ add(a, b)  ; `@` means "return"
    )

Functions are called by reference with parenthesis.

    add(1, 2)  ; computed as 3

Functions carry some properties of data types, in that functions can also be passed by reference to other functions.

    map([1], add)

The number of arguments do not have to match the function definition when calling.

    add(1)
    add(1, 2, 3)

Functions allow recursion.

References to functions which receive or return mutable types should be prefixed with `$` to indicate the function may mutate data.

**Conditions.** `if` statements are a very familiar syntax.

    set(f, (a, b)
        if is(a, b)
            @ true
        else
            @ false
    )

Conditional blocks are expressions.

    set(c, if a is b
        true
    else
        false)

Type must be explicitly converted for comparison. `if` statements do not convert type. If you try to compare two different types, you will get an error.

**Loops.** Both `while` and `for` loops are available. `while` loops expect a boolean and a block.

    while true
        add(1, 2)

`for` loops expect an iterative and a block. An iterative always takes the expression `for {reference(s)} in {data}`.

    for i in [0, 1, 2]
        add(a, i)

    for i in range(0, 10)
        add(a, i)

    for index, value in range(0, 10)
        set(a, index, value)

    for value in {'a' = 1, 'b' = 2}
        add(a, value)

    for key, value in {'a' = 1, 'b' = 2}
        set(a, key, value)

`break` and `continue` are available as is common in most languages.

**Error Handling.** TODO

    try
        statements
    catch exception
        statements

    assert condition

    throw exception

Aliased Garden
--------------


Aliases give Garden a much more familiar syntax. Aliases are not required, the language can be fully used without touching a single alias.

**Common aliases.** Unlike their functional equivalents, aliases do observe standard order of operations. Numbers have the most aliases.

- `=` is an alias of `set()`
- `+` is an alias of `add()` or `concat()`
- `-` is an alias of `subtract()`
- `*` is an alias of `multiply()`
- `\` is an alias of `divide()`
- `^` is an alias of `power()`
- `%` is an alias of `modulus()`
- `@` is an alias of `import()`
- `and` is an alias of `and()`
- `or` is an alias of `or()`
- `not` is an alias of `not()`
- `is` is an alias of `is()`
- `eq` is an alias of `equals()`
- `isnt` is an alias of `not(equals())`
- `<` is an alias of `lessThan()`
- `>` is an alias of `greaterThan()`
- `<=` is an alias of `or(lessThan(), equals())`
- `>=` is an alias of `or(greaterThan(), equals())`
- `?` aliases `equals(getType(a), none)`
- `++` aliases `increment(n, 1)`
- `--` aliases `decrement(n, 1)`
- `+=` aliases `increment(a, b)`
- `-=` aliases `decrement(a, b)`

To get a feel for what's happening underneath, here's a few examples of things that are equivalent expressions.

    1 + 2
    add(1, 2)

    1 + 2 * 3
    add(1, multiply(2, 3))

    1 * 2 + 3
    add(multiply(1, 2), 3)

    (1 + 1) * 1  ; Parenthesis can be used to overwrite order of operations.
    multiply(add(1, 1), 1)

    true and true
    and(true, true)

    [1, 2, 3].0
    get([1, 2, 3], 0)

    $[1, 2, 3].0 = 2
    set($[1, 2, 3], 0, 2)

**Chained comparisons.** Thanks to the aliases, chained comparisons are allowed.

    if a > b > c
        @ true

**Non-alias keywords.** Several control statements are not aliases. `if`, `else`, `for`, `while`, `break`, `continue`, `@`, `try`, `catch`, `assert`, and `throw` are not aliases. They are part of the core language.

**Accessor aliases.** Tuples, lists, maps, and objects provide commonplace aliases for accessing and setting values.

- `.` aliases `get()` and `set()`. This alias interpolates type as number or string.
- `[]` also aliases `get()` and `set()`. `[]` does not interpolate type.
- `contains` and `in` are aliases of `in()`.
- TODO examples

**Comprehensions.** Comprehensions, borrowed from Python, are more complex aliases that provide convenience for crafting new tuples, lists, maps, and objects from existing data.

    [a for a in [0, 1, 2]]

    A = []
    for a in [0, 1, 2]
        A.append(a)

    {k = v for k, v in {'a' = 1, 'b' = 2, 'c' = 3}}

**Destructure alias.** A tuple or list of items can be assigned to individual elements.

    a, b = [0, 1]
    set(a, 0)
    set(b, 1)

**Import alias.** A alias of `import` is `@`. When using the alias, strings are assumed. It will be set to the name of the module, but prefixing with an assignment can change the name.

    @ ./path/to/module
    module2 = @ ./path/to/otherName

**Blocked alias.** Lists of things separated may also be separated just by returns.

    a = [1, 2, 3]  ; Inline format.
    b = [
        1
        2
        3
    ]  ; Block format.

    q = {'a' = 1, 'b' = 2, 'c' = 3}  ; Inline format
    q = {
        'a' = 1
        'b' = 2
        'c' = 3
    }  ; In block format

    add = (a, b)
        @ a + b

    add = (
        a
        b
    )  ; In block format.
        @ a + b

**Inline-block alias.** It's often common to have one line functions which serve as an input to another function. In such cases, it may be inconvenient to require a line break. In such cases, the inline-block alias, a colon `:`, can be used.

    filter(c, (a): @ a.name == 'A')
    filter(c, (a)
        @ a.name == 'A')

**Ternary alias.** Many languages feature some kind of way to set a variable based on condition in a single line. It's common to have a variable set by a simple condition. The ternary alias replicates this capability.

    a = if b > 5 then 5 else b
    a = if b > 5
        5
    else
        b

**Pipe alias.** Performing a set of operations on a collection of items, such as filter, map, sort, and reduce can be awkward looking.

    b = reduce(sort(map(filter(a, (c): ...), (c): ...), (c): ...), (c): ...)

Such calls can hide the step-by-step nature of these commands. Instead the pipe alias takes the previous value and adds it as the first argument of the succeeding function call.

    b = a
        | filter((c): ...)
        | map((c): ...)
        | sort((c): ...)
        | reduce((c): ...)

The operator can be used on the same line or on successive lines.

**Keyword alias.** Functions are always in keyword style. This means argument names can always be added for clarity. Without argument names, functions assume the ordering matches the arguments.

    add(b = 2, a = 1)

**Splat alias.** Splats can be used to refer to an addition arguments. Splats are identified as `...`, and may use numeric indexes or strings.

    add = (...)
        @ add(...0, slice(..., 1))

**Type annotation alias.** Optionally, function arguments and returns can have type specified. These simply add runtime warnings, and are not complier enforced or checked as Garden is a dynamic language.

    add = (a:number, b:number)
        @ a + b
    (:number)

Custom Data Types
-----------------

When creating custom data types, other aliases can be defined. Custom data types can be defined. TODO: How do we create these?

Custom data types are not classes. Custom data types can define aliases, and therefore impact how the language itself is compiled.

**Vector.** Vectors are immutable. Vectors are defined as `vector[]` or `vector{}`, supporting implied numeral keys `[]` or other types of keys `{}`. The falsy vector is an empty vector.

**Matrix.** Matrixes are immutable. Matrixes are defined either as `matrix[]` or `matrix{}`, supporting implied numeral keys `[]` or other types of keys `{}`. The falsy matrix is an empty matrix.

**Fraction.**

**Irrational.**

**Date.**

Compiler
--------

Garden uses a 'watch'-based compiler, meaning as changes are detected, the code recompiles. A fast C-based compiler is available for desktop applications, server-side website code, and shell scripting. A JavaScript compiler is available for client-side websites and other scripting applications.

The compiler automatically lints the code for best practices. Some issues will cause the compiler to fail to build, while others will show warnings instead.

Errors: (_Must_)

- Each indent should be four spaces per indent.
- Functions must contain less than ten statements.
- Blocks must not go more than three levels deep.
- Types must match to do a comparison. (Run-time)

Warnings: (_Should_)

- One empty line should be after each block.
- Two spaces should be before starting an inline comment.
- Mutable variable name should be prefixed with `$`. (Run-time)
    - `$` prefix indicates the variable _may_ be mutable, in the case of a function argument.
- One space should be around operator aliases. `= + - / * ^ % :`
- No spaces should be inside binding aliases. `( ) [ ] { }`
- Variable names should be either camelcase or underscores, but not both.
- All imports should be used.
- All variables should be used.
- No lines should have trailing whitespace.
- Lines should be no longer than eighty characters.
- Functions should always end in an explicit return.

Compilations only include specific modules needed.

Standard Library
----------------

Standard library modules version separate of the main language.

**String.** in, find, lowercase, concat, trim, replace, template, split, reverse. `template` interpolates `{var}`.

**Tuple.** length, get, slice, before, after, set, concat, join

**List.** Tuple methods, plus push, pop, shift, unshift, copy...

Example Case: Quicksort
-----------------------

Garden has two syntaxes, one without aliases and one with. Here's a quicksort algorithm without aliases:

    set(list, import('list'))
    set(random, import('random'))
    set(number, import('number'))
    set(quicksort, (a)
        set($less, $[])
        set($equal, $[])
        set($greater, $[])
        if number.greaterThan(list.length(a), 1)
            set(pivot, random.select(list))
            for x in a
                if number.lessThan(x, pivot)
                    list.append($less, x)
                if number.equals(x, pivot)
                    list.append($equal, x)
                if number.greaterThan(x, pivot)
                    list.append($greater, x)
            @ list.concat(
                list.concat(quicksort($less), $equal),
                quicksort($greater)
            )
        else
            @ a
    )

With aliases:

    @ list
    @ random
    quicksort = (a)
        $less, $equal, $greater = $[], $[], $[]
        if list.length(a) > 1
            pivot = random.select(a)
            for x in a
                if x < pivot
                    $less + x
                if x == pivot
                    $equal + x
                if x > pivot
                    $greater + x
            @ quicksort($less) + $equal + quicksort($greater)
        else
            @ a

Example Case: Object-Oriented Programming
-----------------------------------------

While Garden is largely a functional-ish language, it doesn't prevent some object-oriented programming style.

Consider the following **non-Garden** code, which looks like a typical class in other languages.

    ; This is not Garden code
    printer = class  ; Garden does not ship with a class type
        new = (props)
            ; Add properties to instance
        print = ()
            console.print(this.name)  ; Garden has no context of the instance
            @ this.name

Garden does allow storing function references on objects. However, those functions will not have any "context" of how they are called like in the previous non-example.

    @ console

    $a = ${}
    $a.name = 'A'
    $a.print = ($a)
        console.print($a.name)
        @ $a.name
    $a.print()  ; Has no context of `a`

Methods, in the OOP sense, are not possible without an instance context. Garden also does not ship with a class data type. Instead, by clever use of the pipe operator, we can create modules that act as classes.

    ; First module acting as class, `printer`

    @ object
    @ console

    new = (props)
        @ object.extend(${}, props)

    print = ($ins)
        console.print($ins.name)
        @ $ins.name

    ; Another module

    p = @ ./printer

    $a = p.new(${})
    $b = p.new(${})
    $a | p.print()
    $b | p.print()

This isn't exactly object-oriented programming per say, but we gain a few advantages. As functions have no context, its very clear what the inputs are to the function. And because the functions don't belong to a specific object or class, we can reuse them directly without having to consider context as well. This process also forces us to do class-by-composition instead of class-by-inheritance.

More TODOs
----------

- TODO: standard lib module for All data types
- TODO: Reading command line arguments
- TODO: File
- TODO: Exceptions
- TODO: Events and concurrency
- TODO: Threads
- TODO: Message queue and observer pattern
- TODO: Parallel
- TODO: Serialization
- TODO: State machines
- TODO: Math
- TODO: Map Reduce
- TODO: Numeric computation, linear algebra
- TODO: Calculus
- TODO: Combinatorics
- TODO: Statistics
- TODO: REPL
- TODO: Test suites
- TODO: Source maps
- TODO: SQL library
- TODO: Web server
- TODO: Proxy server
- TODO: Web MVC
- TODO: ORM and Migration framework
- TODO: Drivers for popular tools
- TODO: Task runner (e.g. Grunt)
- TODO: Date and Time
- TODO: Heaps, Sets, Queues...
- TODO: Pretty Print
- TODO: Cryptography
- TODO: Compression
- TODO: CSV
- TODO: Logging
- TODO: SSL, HTTP
- TODO: Email
- TODO: JSON
- TODO: Mime
- TODO: HTML
- TODO: XML
- TODO: URL
- TODO: FTP
- TODO: Cookie
- TODO: Audio
- TODO: Image
- TODO: Video
- TODO: OpenGL
- TODO: Fonts
- TODO: CSS
- TODO: Color
- TODO: Internationalization
- TODO: Machine learning
- TODO: Text processing and analysis
- TODO: GUI
- TODO: Doc generator
- TODO: Test suites
- TODO: Debugging
- TODO: Compiler
- TODO: Mac, Unix, Windows Services
- TODO: Plotting
- TODO: Markdown
- TODO: Shell
- TODO: Benchmarking
- TODO: Vagrant/Docker
- TODO: Web socket
- Why? and Why Not? for each decision, pros and cons from other languages
- Review MDN JS Guide
- Review MDN JS Reference
- Review TC39 ECMA-262
- Review http://bonsaiden.github.io/JavaScript-Garden/
- Review Python docs
- Review Ruby docs
- Review Java docs
- Review Coffeescript docs
- Review Lua docs
- Review D docs
- Review Scala docs
- Review Other languages docs
- Review Bitwise operations (?)
- Promises and Async as default for libraries (ala Node.js)
- Review [YACC](http://en.wikipedia.org/wiki/Yacc)
- Write a blog in exclusive literal style to observe natural syntax
- Review [Wolfram's language](http://www.wolfram.com/language/for-experts/)
- Review Lisp docs (compiled, dynamic language)
- Review Go docs
- Review Dart docs
- Review Fortran docs
- Review [Swift docs](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_399)
- Review [wisp docs](https://github.com/Gozala/wisp)
- Review Clojure docs
- Review Matlab, Octave, R docs
- Review LaTeX docs
