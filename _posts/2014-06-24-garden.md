---
layout: post
title: Garden, hypothethical language syntax
---


I've often asked myself as I work throughout the day, as I jump from JavaScript, CoffeeScript, Sass, Stylus, Python, Ruby, Java, HTML templating... _what would it look like for my 'ideal' syntax?_ This evolving post documents my thoughts.

-------

Garden: Syntax Definition
=========================

Version 0.0.0 - Planning; See [SemVer](http://semver.org/)

This document is the beginning of a plan for a hypothetical language syntax. It will change, grow, and update frequently as I continue to research for the project. There is no plan to implement this syntax.

The name "Garden" is a placeholder for now until something better comes along.

This project started as a idea: if I were to design a programming language, what system by which would I design it? How would I go about making decisions? What would it look like?

I see the inconsistencies in other languages I commonly use, or barriers to entry, and I want to resolve these issues, even if only hypothetically. Some languages have stood the test of time better than others. We also have the reality that new paradigms come and go frequently in programming. Ideally, a language would be able to survive and adapt quickly to these changes while still staying consistent at its core.

I find myself, perhaps like many programmers, imagining the ideal language. What I'm presenting however, is perhaps not ideal, but somewhere between practical and ideal.

I'm still exploring this idea. So anything in this document is likely and open to change.

* * *

1) Objectives and Taxonomy
--------------------------

### 1.1 Styles

- **Procedural**: Paradigm based on procedural calls to carry out functions.
- **Imperative**: Paradigm where program functions based on state.
- **Object-Oriented**: Paradigm that focuses on repeatable instances and functional templating.
- **Event-driven**: Paradigm where flow is controlled by temporal messages.
- Borrows ideas from **Functional**: Paradigm which say computation is the result of mathematical functions. Avoids state and mutablility.
- Safe type, strong, dynamic, and implicit

### 1.2 Intended Use

- Server-side Web
    - Fast C-based compiler
    - "Watch"-based command line capability
- Client-side Web
    - JavaScript compiler
- Scripting
- Application Development
- Shell

### 1.3 Objectives

**Language**

- Do the most with the least possible. Omit things that are not needed.
- Be as explicit as possible without being redundant. Explicit while concise.
- Modularize.
- Keep it DRY.
- Almost everything is actually an object or an function.
- Be as uniform as possible even across data types.
- Prefer one way to do things. Explain exceptions to this.
- Every type of object has one falsy representation.
- A test of readability: I should be able to read it outloud to a non-programmer as-is.
- Encourage flat structures; use the least amount of abstraction necessary.
- Throw errors loud and often when unexpected behavior occurs.

**Docs**

- Be familiar and thoughtful.
- Present clear pros and cons to each issue.
- Research all decisions based on prior conversations from other languages.

2) Syntax
---------

### 2.1 Statement Seperator

- Newline `\n` terminated
- Parenthesis `()` for continuation if absolutely necessary

### 2.2 Variable Declaration

    a.set(1)  ; Function form
    a = 1  ; `=` is an alias of `.st()`
    a.toString()  ; convert type
    a.getType()  ; returns type as string

- No keywords required
- Defaults to as local of scope as possible (lexical)
- Block-scoped by default
- Will refer to higher definition if exists
- Multiple assignment

### 2.3 Namespacing

Import is a global function, the only global function.

File names are used as module names.

Errors on compile if there is any cyclical import. Imports must form a tree.

    module1.set(import('module'))
    module2 = import('module')  ; `=` is an alias of `.set()`
    method = import('module').method
    module3 = import('module')

### 2.4 Comments

    ; A singleline comment
    ;
        A multiline comment

- Just `;` semicolons
- Regex defined by simple string instead
- Multiline comments just indent after a `;`
- Why semicolons?
    - No shift key
    - Not easily mistaken for other operation
    - Require one key
    - Easy to reach
    - Problems with the others:
        - Requires shift key `~` `!` `@` `#` `$` `%` `^` `&` `*` `(` `)` `_` `+` `{` `}` `|` `:` `"` `<` `>` `?`
        - Other operation `-` `=` `[` `]` `'` `,` `.` `/`
        - Hard to reach `` `
        - Requires two keys `//` `--` `/* */` `(* *)` `[[ ]]` `-- --`

3) Types
--------

### 3.1 Nothing

    none

When a variable has not been defined, or holds no value, it should return `none`.

- Is falsy.
- Conversion: `a.delete()`
- None, Boolean, Number, and String are basic types; clones on reference

### 3.2 Boolean

    true
    false
    true.and(false)
    true and false  ; Alias of above
    true.or(false)
    true or false  ; Alias of above
    true and false or true  ; Aliases
    true.and(false).or(true)  ; Typically, aliases chain
    true or false and true  ; When alias, observe order of operations
    true.or(false.and(true))  ; Same as above
    true.not()  ; Negate
    not true  ; Alias of above

- Conversion: `a.toBoolean()`
- Falsy: `false`

### 3.3 Numbers

    1
    1.add(1)
    1 + 1  ; alias of `add`
    1.subtract(1)
    1 - 1  ; alias of `subtract`
    1.divide(1)
    1 / 1  ; alias of `divide`
    1.multiply(1)
    1 * 1  ; alias of `multiply`
    1.power(1)
    1 ^ 1  ; alias of `power`
    1.modulus(1)
    1 % 1  ; alias of `modulus`
    1.increment()
    1++  ; alias of `increment`
    1.decrement()
    1--  ; alias of `decrement`
    1.increment(2)
    1 += 2  ; alias of `increment(2)`
    1.decrement(2)
    1 -= 2  ; alias of `decrement(2)`
    1 + 1 - 1
    1.add(1).subtract(1)  ; Typically, aliases chain
    1 + 2 * 3  ; Order of operations observed
    1.add(2.multiply(3))  ; Same as above
    1 * 2 + 3
    3.add(1.multiply(2))  ; Same as above

- Only one type of number
- Dynamically adjust memory size to fit
- Conversion: `a.toNumber()`
- Falsy: `0`
- Assume numbers very near whole integers will convert as such

### 3.4 Strings

    'Hello world'
    'Hello world'.get(0)  ; Array operations allowed
    'Hello world'[0]  ; `[x]` is alias of `.get(x)`
    'Hello world'.contains('wor')
    'Hello world'.find('wor')  ; Returns index
    'Hello world'.lowercase()  ; Built-in methods
    'Hello world'.uppercase()
    'Hello world'.concat('!')
    'Hello world' + '!'  ; `+` aliases `.concat`
    'Hello world'.trim()
    'Hello world'.replace('Hello', 'Goodbye, cruel')
    'Oh my, {a}!'.template(a = 'world')  ; Interpolation
    'Hello world'.split(',')
    'Hello world'.reverse()
    '
        A multline string

- Single quotes `'`
- Regular expressions are just strings
- Multiline regular expressions allowed
- Intepolate with `{}`
- Escape with `\`, as in `\'` or `''`
- Compared with UTF-8 value ordering
- Conversion: `a.toString()`
- Falsy: `''`, emptry string

### 3.5 Array

    [1, 2, 3]  ; In singleline format

    [
        1
        2
        3
    ]  ; In multiline

    [1, 2, 3].length  ; Measures length
    [1, 2, 3].get(0)  ; Retrieve by index
    [1, 2, 3][0]  ; Alias of `get`
    [1, 2, 3].0  ; Another alias of `get`
    [1, 2, 3][-1]  ; Negative indexes allowed
    [1, 2, 3].after(1)  ; Returns a slice
    [1, 2, 3].slice(0, 1)  ; Returns a slice, inclusive
    [1, 2, 3].set(3, 4)
    [1, 2, 3][3] = 4  ; Alias of `set`
    [1, 2, 3].3 = 4  ; Another alias of `set`
    [1, 2, 3].concat([1, 2, 3])
    [1, 2, 3].add([1, 2, 3])  ; Vector operations
    ['a', 'b', 'c'].join()  ; Join, must all be strings or error
    [1, 2, 3].copy()

- `[]`
- Embedding allowed, also known as multidimensional
- Dynamically-sized
- Vector operations
- Indexes start at zero
- Throws error if bound check fails
- Methods for set, vector, tuple casting
- Matrix and linear algebra methods
- Functional programming methods
- Falsy: `[]`
- Conversion: `a.toArray()`
- Push, pop, shift, unshift...
- Arrays, Hashes, Objects, Functions are complex types; references
    - Use `.copy()` for a new one

### 3.6 Objects (also known as Hashes or Dictionaries)

    q = {'a' = 1, 'b' = 2, 'c' = 3}  ; Commas optional
    ; Keys are explicit string, other types allowed
    q = {
        'a' = 1
        'b' = 2
        'c' = 3
    }  ; In multiline

    q['a'] ; Get a value ;
    q.a ; Convenience method ;
    q['d'] = 4 ; Set a value ;
    q.delete('d') ; Remove a value at key ;

- `{}`
- Embedding allowed
- Unordered
- Falsy: `{}`, empty object
- Conversion: `a.toObject()`

### 3.7 Functions

    ; Defining a function
    (arg1, arg2)
        a = arg1 + arg2
        return a

    ; Setting a variable to a function
    foo.set((arg1, arg2)
        a = arg1 + arg2
        return a
    )

    ; or...
    foo = (arg1, arg2)
        a = arg1 + arg2
        return a

    ; Calling a function...
    foo(arg1, arg2)

    ; In multiline, we can drop commas
    foo(
        arg1
        arg2
    )  

    ; Keywords
    foo(arg2 = 2, arg1 = 2)

- All function arguments are keyword style
- Assumes ordering match if not specified
- Always use parenthesis
- Number of arguments do not need to match
- Splats with `...`, no need to reference before using
- Recursion allowed
- Functions are first-class, and can be passed by reference and have properties and methods

### 3.6 Classes

    ; Classes are just wrappers of objects
    class({
        bar = (a, b)
            return a + b
    })

    ; Class, followed by indented block, is an alias
    class
        bar = (a, b)
            return a + b

    ; Variables can be set to classes
    F = class
        bar = (a, b)
            return a + b

    ; Classes have a constructor of `new`
    F = class
        new = (a, b, c)  ; !Special! Constructor function
            self.a = a  ; Self is the instance
            class.b = b  ; Class
            super.c = c  ; Parent class reference

    ; Classes can be extended
    B = class.extends(G)({
        foo = (a, b)
            return a * b
    })

    ; `Extends` has an alias too
    B = class extends G
        foo = (a, b)
            return a * b

    a = F.new(arg1)  ; Create a new instance
    a['bar'](arg1)
    a.bar(arg1)
    a.has('bar')  ; Does the property exist?
    a.bar.isFunction()  ; Is the property a method?

- Overloading operators okay, including get and set
- Encapsulation - start name with a single underscore to indicate private
- Getters and setters

4) Control Statements
---------------------

TODO: Rework this section

### 4.1 Conditionals

    if condition
        statements
    else if
        statements
    else
        statements

Can be written in a single line, also for assignment:

    a = if condition, statement else statement

Switch statements have no explicit `break`

    switch value
        if 1
            statements
        if 2
            statements
        else
            statements

- Equals: `==` or `is`
- Does not equal: `!=` or `isnt`
- Not: `!` or `not`
- Less than: `<` or `lt`
- Greater than: `>` or `gt`
- Less than or equal: `<=` or `lte`
- Greater than or equal: `>=` or `gte`
- Contains: `a in b`
- And: `a && b` or `a and b`
- Or: `a || b` or `a or b`
- Exists: `a?` or `a != none`
- No explicit conversion, comparing different types is an error
- Chained comparisons okay
- Parenthesis overrides precedence

### 4.2 Loops

    while condition
        statements

    do
        statements
    while condition

    for number in 0 to 9  ; inclusive
        statements

    for number in 9 to 0
        statements

    for value in array
        statements

    for index = value in array
        statements

    for value in hash
        statements

    for key = value in hash
        statements

Also uses `break` and `continue`

### 4.3 Comprehensions

    [a for a in [0 1 2]]
    {k = v for k = v in {'a' = 1, 'b' = 2, 'c' = 3}}

### 4.4 Exceptions

    try
        statements
    catch exception
        statements

    assert condition

    throw exception

5) Autolinting
--------------

- Warn on compile instead of error
- Requires four spaces per tab
- Requires one line after a block
- Requires one empty line at end of file
- Requires one spaces before starting comment
- Requires conventions
    - One space around operators: `= + - / * ^ % :`
    - No space inside `( ) [ ] { }`
    - TODO: Explicit rules
- Complexity and number of statements
- No bitwise operations
- CamelCase defaults
- No overwriting natives, extensions allowed
- Empty blocks
- Unused imports, variables, objects
- No trailing whitespace
- Maximum unkeyword arguments
- Maximum block depth
- Maximum line length
- Debug mode
- No string eval method
- No total globals
- Browser, other variables always explicitly imported
- Naming conventions: functions, objects, number etc

6) Standard Library
-------------------

Standard library modules version separate of the main language.
Compilations only include specific entities needed.

- TODO: Reading command line arguments
- TODO: File
- TODO: Exceptions
- TODO: Events and concurrency
- TODO: Threads
- TODO: Message queue and observer pattern
- TODO: Parallel
- TODO: Serialization
- TODO: State machines
- TODO: Math
- TODO: Map Reduce
- TODO: Numeric computation, linear algebra
- TODO: Calculus
- TODO: Combinatorics
- TODO: Statistics
- TODO: REPL
- TODO: Test suites
- TODO: Source maps
- TODO: SQL library
- TODO: Web server
- TODO: Proxy server
- TODO: Web MVC
- TODO: ORM and Migration framework
- TODO: Drivers for popular tools
- TODO: Task runner (e.g. Grunt)
- TODO: Date and Time
- TODO: Heaps, Sets, Queues...
- TODO: Pretty Print
- TODO: Cryptography
- TODO: Compression
- TODO: CSV
- TODO: Logging
- TODO: SSL, HTTP
- TODO: Email
- TODO: JSON
- TODO: Mime
- TODO: HTML
- TODO: XML
- TODO: URL
- TODO: FTP
- TODO: Cookie
- TODO: Audio
- TODO: Image
- TODO: Video
- TODO: OpenGL
- TODO: Fonts
- TODO: CSS
- TODO: Color
- TODO: Internationalization
- TODO: Machine learning
- TODO: Text processing and analysis
- TODO: GUI
- TODO: Doc generator
- TODO: Test suites
- TODO: Debugging
- TODO: Compiler
- TODO: Mac, Unix, Windows Services
- TODO: Plotting
- TODO: Markdown
- TODO: Shell
- TODO: Benchmarking
- TODO: Vagrant/Docker
- TODO: Web socket

TODOs
-----

- Why? and Why Not? for each decision, pros and cons from other languages
- Review MDN JS Guide
- Review MDN JS Reference
- Review TC39 ECMA-262
- Review http://bonsaiden.github.io/JavaScript-Garden/
- Review Python docs
- Review Ruby docs
- Review Java docs
- Review Coffeescript docs
- Review Lua docs
- Review D docs
- Review Scala docs
- Review Other languages docs
- Review Bitwise operations (?)
- Promises and Async as default for libraries (ala Node.js)
- Review [YACC](http://en.wikipedia.org/wiki/Yacc)
- Write a blog in exclusive literal style to observe natural syntax
- Review [Wolfram's language](http://www.wolfram.com/language/for-experts/)
- Review Lisp docs (compiled, dynamic language)
- Review Go docs
- Review Dart docs
- Review Fortran docs
- Review [Swift docs](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_399)
- Review [wisp docs](https://github.com/Gozala/wisp)
- Review Clojure docs
- Review Matlab, Octave, R docs
- Review LaTeX docs
